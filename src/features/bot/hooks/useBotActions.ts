import { storeToRefs } from 'pinia';
import { useBotStore } from '../stores/botStore';
import { useBotLog } from './useBotLog';
import { axiosInstance } from '@/app/config';

const authApi = axiosInstance;

export const useBotActions = () => {
  const botStore = useBotStore();
  const { addLog } = useBotLog();

  const {
    cookies,
    isPublishing,
    isBotRunning,
    publishCount,
    postsPerAccount,
    autoGenerateDraft,
    autoSchedule,
    keywords,
    service,
    refText,
    generateImages,
    imageCount,
    delayBetweenPosts,
    scheduleDate,
    scheduleStartHour,
    scheduleIntervalHours,
    scheduleIntervalMinutes,
    currentAccount,
    keywordList,
    useManualAccount,
    ACCOUNTS,
  } = storeToRefs(botStore);

  const handlePublish = async () => {
    if (isPublishing.value) return;

    if (!cookies.value) {
      addLog('ERROR', '발행 실패', '로그인이 필요합니다');
      return;
    }

    isPublishing.value = true;
    addLog('INFO', '블로그 발행 시작...');

    try {
      const response = await authApi.post('/bot/publish', {
        cookies: cookies.value,
        count: publishCount.value,
        auto_generate_draft: autoGenerateDraft.value,
        use_schedule: autoSchedule.value,
        schedule_date: scheduleDate.value || undefined,
        schedule_start_hour: scheduleStartHour.value,
        schedule_interval_hours: scheduleIntervalHours.value,
        schedule_interval_minutes: scheduleIntervalMinutes.value,
      });

      const { success, published = 0, message, error } = response.data;

      if (success) {
        addLog('SUCCESS', '발행 완료', `${published}개 발행됨`);
      } else {
        addLog('ERROR', '발행 실패', error || message);
      }
    } catch (error: unknown) {
      const axiosError = error as { code?: string; message?: string };
      if (
        !(
          axiosError.code === 'ECONNABORTED' ||
          axiosError.message?.includes('timeout')
        )
      ) {
        addLog('ERROR', '발행 실패', axiosError.message);
      }
    } finally {
      isPublishing.value = false;
    }
  };

  const handleStartBot = async () => {
    if (isBotRunning.value) return;

    if (ACCOUNTS.value.length === 0) {
      addLog('ERROR', '자동화 실패', '계정 정보가 없습니다');
      return;
    }

    isBotRunning.value = true;
    addLog('INFO', '자동화 봇 시작...', `${ACCOUNTS.value.length}개 계정`);

    try {
      const response = await authApi.post('/bot/start', {
        accounts: ACCOUNTS.value.map((acc) => ({
          id: acc.id,
          password: acc.password,
        })),
        posts_per_account: postsPerAccount.value,
      });

      const { success, message, error, results } = response.data;

      if (success) {
        addLog('SUCCESS', '자동화 완료', message);
        results?.forEach(
          (r: { account: string; published: number; error?: string }) => {
            if (r.error) {
              addLog('WARNING', `${r.account}`, r.error);
            } else {
              addLog('INFO', `${r.account}`, `${r.published}개 발행`);
            }
          }
        );
      } else {
        addLog('ERROR', '자동화 실패', error || message);
      }
    } catch (error: unknown) {
      const axiosError = error as { code?: string; message?: string };
      if (
        !(
          axiosError.code === 'ECONNABORTED' ||
          axiosError.message?.includes('timeout')
        )
      ) {
        addLog('ERROR', '자동화 실패', axiosError.message);
      }
    } finally {
      isBotRunning.value = false;
    }
  };

  const handleStopBot = () => {
    addLog('WARNING', '자동화 중지 요청');
    isBotRunning.value = false;
  };

  const handleAutoBot = async () => {
    if (isBotRunning.value) return;

    const account = currentAccount.value;
    if (!account?.id || !account?.password) {
      addLog(
        'ERROR',
        '계정 정보가 없습니다',
        useManualAccount.value
          ? '아이디/비밀번호를 입력하세요'
          : 'ACCOUNTS 배열에 계정을 추가하세요'
      );
      return;
    }

    if (keywordList.value.length === 0) {
      addLog('ERROR', '키워드를 입력해주세요');
      return;
    }

    isBotRunning.value = true;
    addLog('INFO', '전체 자동화 시작...', `${keywordList.value.length}개 키워드`);

    try {
      const response = await authApi.post('/bot/auto', {
        account: { id: account.id, password: account.password },
        keywords: keywordList.value,
        service: service.value || 'default',
        ref: refText.value,
        generate_images: generateImages.value,
        image_count: imageCount.value,
        use_schedule: autoSchedule.value,
        schedule_date: scheduleDate.value || undefined,
        schedule_start_hour: scheduleStartHour.value,
        schedule_interval_hours: scheduleIntervalHours.value,
        schedule_interval_minutes: scheduleIntervalMinutes.value,
        delay_between_posts: delayBetweenPosts.value,
      });

      const {
        success,
        generated = 0,
        published = 0,
        failed = 0,
        elapsed,
        results,
        error,
        message,
      } = response.data;

      if (success) {
        addLog(
          'SUCCESS',
          '전체 자동화 완료',
          `생성: ${generated}, 발행: ${published}, 실패: ${failed}, 소요: ${elapsed?.toFixed(1)}초`
        );
        results?.forEach(
          (r: {
            manuscript_id: string;
            success: boolean;
            post_url?: string;
            error?: string;
          }) => {
            if (r.success) {
              addLog('INFO', `원고 ${r.manuscript_id}`, r.post_url);
            } else {
              addLog('WARNING', `원고 ${r.manuscript_id}`, r.error);
            }
          }
        );
        keywords.value = '';
      } else {
        addLog('ERROR', '전체 자동화 실패', error || message);
      }
    } catch (error: unknown) {
      const axiosError = error as { code?: string; message?: string };
      if (
        !(
          axiosError.code === 'ECONNABORTED' ||
          axiosError.message?.includes('timeout')
        )
      ) {
        addLog('ERROR', '전체 자동화 실패', axiosError.message);
      }
    } finally {
      isBotRunning.value = false;
    }
  };

  return {
    handlePublish,
    handleStartBot,
    handleStopBot,
    handleAutoBot,
  };
};
